.menu {
    /* position: relative; */
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10;

    display: grid;
    grid-template-rows: auto 1fr;

    background: #000b;
    border: 4px solid var(--brown);
    padding: 1em;
    animation: menuFade 0.4s reverse both ease-in-out;

    &.visible {
        animation: menuFadeBullshitCopy 0.4s both ease-in-out;
    }

    & h1 {
        color: var(--blue);
        font-size: 1.5em;
        padding-bottom: 0.3em;
        margin-bottom: 0;
        border-bottom: 2px solid var(--darkbrown);
    }
}

.switch .menu {
    animation-duration: 0.01s;
}

/* Dumbest CSS hack I've ever needed to do. Animation won't retrigger when .visible is toggled because it's the same animation, even though the assigned values of animation change because the actual animation is the same. So short of hacking in animation: none with JS using setTimeout, the easiest way to fix this problem is to make a duplicate of the animation so that on paper, the animation is TOTALLY DIFFERENT wink wink. */
@keyframes menuFadeBullshitCopy {
    0% { 
        opacity: 0;
        pointer-events: none;
        transform: scale(0.95);
    }
    70% {
        transform: scale(1);
    }
    100% {
        opacity: 1;
    }
}


@keyframes menuFade {
    0% { 
        opacity: 0;
        pointer-events: none;
        transform: scale(0.95);
    }
    70% {
        transform: scale(1);
    }
    100% {
        opacity: 1;
    }
}


.allies {
    display: grid;
    grid-template-columns: repeat(6, auto);
    justify-content: center;
    align-content: start;
    padding: 2.5em 1.5em 1.5em;
    gap: 2em;
    overflow: auto;
}